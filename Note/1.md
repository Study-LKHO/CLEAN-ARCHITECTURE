# 1부

## 1장. 설계와 아키텍처란?

- 아키텍처
    - 저수준의 세부사항과는 분리된 고수준의 무언가를 가리킬 때 흔히 사용
- 설계
    - 저수준의 구조 또는 결정사항 등을 의미할 때가 많음
- 설계 vs. 아키텍처
    - 둘 사이에는 차이가 없음
    - 아키텍트가 실제로 하는 일을 살펴보면 이러한 구분은 무의미함

### 목표

- 소프트웨어 아키텍처의 목표
    - 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있음
    - 결함을 줄이고, 최소한의 노력으로 기능과 유연성을 최대화

### 사례 연구

- 좋지 않은 설계는 개발자의 수는 지속적으로 증가하지만 코드 생산성은 한 곳으로 수렴
    - 생산성이 개발자 수에 비례하지 않음
    - 추가적으로 코드 한 라인당 비용이 기하급수적으로 상승함

- ‘지저분한 코드 작성’ → ‘단기간에 빠르게 갈 수 있고, 장기적으로 볼 때 생산성은 감소’
- ‘자신을 과신’ → ‘재설계해도 원래 프로젝트처럼 엉망으로 내몰림’

## 2장. 두 가지 가치에 대한 이야기

- 소프트웨어 개발자는 행위 (Behavior) 와 구조 (Structure) 를 모두 반드시 높게 유지해야 하는 책임을 짐

### 행위

- 말 그대로 동작
- 많은 프로그래머들이 이를 전부라 생각함 (일단 동작하면 장땡이라는 생각을 하는 듯)
- 요구사항을 기계에 구현하고 버그가 난다면 그것을 수정하는 일이 자신의 직업이라 생각 (사전에 버그를 잡을 생각을 안함)

### 아키텍처

- 소프트웨어 : Soft + Ware → 부드러운 제품
- 소프트웨어는 본연의 목적을 추구하려면 반드시 부드러워야 함
- 아키텍처는 종착지가 아닌 여정에 가까우며, 계속된 탐구 과정에 가까움

빨리 가는 유일한 방법은 제대로 가는 것이다.

# 2부

## 3장. 패러다임 개요

- 패러다임은 무엇을 해야 할지를 말하기보다 무엇을 해서는 안 되는지를 말해줌
- 구조적, 객체지향, 함수형 각 패러다임은 개발자에게서 권한을 박탈
- 각각 goto 문, 함수 포인터, 할당문을 뻇어가는데 더 이상 우리에게 뺏어갈 것이 남지 않은 관계로 프로그래밍 패러다임은 딱 3가지 밖에 없을 것.

## 4장. 구조적 프로그래밍

- 우리는 모두 구조적 프로그래머이며, 선택지는 없다. 제어흐름을 제약없이 직접 전환(goto)할 수 있는 선택권 자체를 언어에서 제공하지 않기 때문.
- 구조적 프로그래밍이 오늘날까지 가치 있는 이유
    - 프로그래밍을 반증 가능한 단위로 만들어 낼 수 있는 능력 때문
    - 현대적 언어가 아무런 제약 없는 goto 문장을 지원하지 않는 이유
    - 아키텍처 관점에선 기능적 분해를 최고의 실천법 중 하나로 여기는 이유
- 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록 (테스트 하기 쉽도록) 만들기 위해 분주히 노력해야 함

## 5장. 객체 지향 프로그래밍

- 좋은 아키텍처를 만드는 일은 객체 지향 설계 원칙을 이해하고 응용하는데서 출발한다.

### 캡슐화

- OO (Object-Oriented) 가 강력한 캡슐화에 의존한다는 정의는 받아들이기 힘듦
    - 많은 OO 언어가 캡슐화를 강제하지 않음
- OO  프로그래밍은 프로그래머가 충분히 올바르게 행동 (캡슐화 데이터 우회 X) 한다는 믿음을 기반
- OO 를 제공한다고 주창한 언어들이 실제로는 완벽한 캡슐화 (C 언어에서 누린) 를 약화시킴

### 상속

- OO 언어가 상속만큼은 확실히 제공함
- OO 언어 고안되기 전에도 상속과 비슷한 기법이 사용되었음
    - 그러나 흉내만 냈지 상속만큼 편리한 방식은 아님
- OO 언어가 완전히 새로운 개념을 만들지는 못함
    - 그러나 상속을 제공함으로 편의성을 준 것은 맞음

### 다형성

- 함수가 가리키는 포인터를 응용한 것이 다형성
    - 그러나 함수의 포인터를 직접 사용하여 다형적 행위를 만드는 과거의 방식 문제가 있음
        - 포인터를 통해 모든 함수를 호출하는 관례를 지켜야 함 (위험함)
        - 만약 이를 지키지 않으면 버그 발생 (찾아내고 없애기가 지독히 힘듦)
        - OO 언어는 이러한 관례를 없애줌 (실수할 위험 없음, 다형성은 대수롭지 않은 일)
        - 이러한 이유로 제어 흐름을 간접적으로 전환하는 규칙을 부과함
- 다형성을 안전하고 편리하게 제공한다는 사실은 소스코드의 의존성을 어디에서든 역전 시킬 수 있다는 뜻
    - 이러한 접근법을 통해 아키텍트는 시스템의 소스코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적 권한을 가짐 (소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않음)

### 결론 (OO 란 무엇?)

- OO 란 다형성을 이용하여 전체 시스템의 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력
- OO 를 사용하면 플러그인 아키텍처를 구성할 수 있음
    - 저수준의 세부사항은 플러그인 모듈로 만들고, 고수준의 정책을 포함하는 모듈과 독립적으로 개발하고 배포할 수 있음

## 6장. 함수형 프로그래밍

### 불변성과 아키텍처

- 만약 어떠한 변수도 갱신되지 않는다면 경합 조건이나 동시 업데이트 문제가 일어나지 않음
    - 락 (lock) 이 가변적이지 않다면 교착상태도 일어나지 않음
    - 동시성 애플리케이션에서 마주치는 모든 문제는 가변 변수가 없으면 절대 생기지 않음
- 스레드와 프로세스가 여러개인 상황에서도 설계한 시스템이 여전히 강건하기 바람

### 가변성의 분리

- 애플리케이션을 제대로 구조화 하기 위해 불변 컴포넌트와 가변 컴포넌트를 분리하는 것이 좋음
    - 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트는 분리해야 함
    - 가변 변수들을 보호하는 적절한 수단을 동원해 뒷받침해야 함

### 이벤트 소싱

- 상태가 아닌 트랜잭션을 저장하는 전략
- 상태가 필요해지면 시작점부터 모든 트랜잭션을 처리함
- 특정 시점을 기록하고 시작점부터 다시 읽어들이는 지름길 또한 존재함
- CRUD 가 아니라 CR 만 수행하므로 동시성 문제가 발생하지 않음
- 소스 코드 버전 관리 시스템이 정확히 이 방식으로 동작함

### 결론

- 소프트웨어는 순차, 분기, 반복, 참조로 구성된다. (그 이상, 그 이하도 아님)
