# 4부

## 12장 컴포넌트
컴포넌트는 시스템의 구성요소로 배포할 수 있는 가장 작은 단위  (Java-`.jar`, Ruby-`.gem`, iOS - `.ipa`)  
여러 컴포넌트를 서로 링크해서 실행 가능한 단일 파일로 생성할 수 있음  
잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능함, 따라서 독립적으로 개발 가능한 능력을 갖춰야함

### 컴포넌트의 간략한 역사
메모리가 너무 작아서 소스 코드 전체를 메모리에 상주시킬 수 없었음  
컴파일 시간을 단축시키기 위해 프로그래머는 함수 라이브러리의소스 코드를 애플리 케이션 코드로부터 분리  
프로그램과 라이브러리가 사용하는 메모리가 늘어날 수록 이와 같은 단편화는 계속 될 수 밖에 없었음

### 재배치성
해결책은 재배치가 가능한 바이너리 relocatable binary  
지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정  
링킹로더 Linking Loader : 외부 정의를 로드할 위치가 정해지기만 하면 로더가 외부 참조를 외부 정의에 링크시킬 수 있음

### 링커
링킹 로더가 너무 느려지는 시기가 옴  
로드와 링커를 분리함, 컴파일-링크 시간이 병목 구간  
하드웨어의 발전으로 로드와 링크가 동시에 가능  
컴포넌트 플러그인 아키텍처 Component Plugin Architecture가 탄생

### 결론
소프트웨어 컴포넌트 : 런타임에 프러그인 형태로 결합할 수 있는 동적 링크파일  
현재는 기본으로 쉽게 컴포넌트 플러그인 아키텍처를 적용할 수 있음

## 13장 컴포넌트 응집도
어떤 클래스를 어떤 컴포넌트에 포함시켜야 하는 지는 중요한 결정사항  
컴포넌트 응집도와 관련된 세가지 원칙  
- REP, Reuse/Release Equivalence Principle : 재사용/릴리스 등가 원칙
- CCP, Common Closure Principle : 공통 폐쇄 원칙
- CRP, Common Reuse Principle : 공통 재사용 원칙

### REP : 재사용/릴리스 등가 원칙
> 재사용 단위는 릴리스 단위와 같음

소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함  
컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야함  

릴리즈 문서 작성과 릴리즈 번호를 주는 이유  
* 릴리스 번호가 없다면 재사용 컴포넌트들이 서로 호환되는지 보증할 방법이 전혀없음
* 새로운 버전이 언제 출시되고 무엇이 변했는지 소프트웨어 개발자들이 알아야함

### CCP: 공통 폐쇄 원칙

**CCP는 `SRP`를 컴포넌트 관점에서 다시 쓴 것**, 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안됨  
대부분의 애플리케이션에서 유지보수성은 재사용성 보다 훨씬 중요  
애플리케이션 코드가 반드시 변경되어야 한다면, 여러 컴포넌트에 분산되어 발생하기보다 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다  
* 변경된 컴포넌트에 의존하지 않는 다른 컴포넌트는 다시 검증하거나 배포할 필요 없음
* 소프트웨어를 릴리즈, 재검증, 배포하는 일과 관련된 작업량을 최소화 할 수 있음  
> SRP : 서로 다른 이유로 변경되는 메서드를 서로 다른 클래스로 분리  
> CCP : 서로 다른 이유로 변경되는 클래스를 서로 다른 컴포넌트로 분리  
> * 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶기,   
> 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하기

**CCP는 `OCP` 원칙과도 유사함**,  Closure의 의미가 Close와 같음  
발생할 가능성이 있거나 과거에 발생했던 대다수의 공통적인 변경에 대해 클래스가 닫혀 있도록 설계하는 OCP를 확대 적용해서,  
CCP에서는 동일한 유형의 변경에 대해 닫혀 있는 클래스들을 하나의 컴포넌트로 묶음

### CPR: 공통 재사용 원칙
> 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 않기

CRP도 클래스와 모듈을 어느 컴포넌트에 위치시킬지 결정할 때 도움되는 원칙.  
재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야함  
컴포넌트 내부에서는 클래스들 사이에 수 많은 의존성이 존재한다 예상 가능  
> Container 클래스와 해당 클래스의 Iterator 클래스가 있을 때, 서로 강하게 결합되어 있기 때문에 함께 재사용 됨    
> 따라서 두 클래스는 동일한 컴포넌트에 위치해야함  

의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야함  
CRP는 어떤 클래스를 한데 묶어도 되는지보다는, 어떤 클래스를 한데 묶어서는 안 되는지에 대해 훨씬 더 많은 이야기를 함  
강하게 결합되지 않은 클래스들은 동일한 컴포넌트에 위치시켜서는 안됨

**CRP는 `ISP`의 포괄적인 버전**, 
> ISP : 사용하지 않는 메서드가 있는 클래스에 의존하지 않기  
> CRP : 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 않기  
> " 필요하지 않는 것에 의존하지 않기 "

### 컴포넌트 응집도에 대한 균형 다이어그램
컴포넌트 응집도에 관해 세 원칙이 상충됨  
REP와 CCP는 포함 inclusive 원칙 - 컴포넌트를 더욱 크게 만듬  
CRP는 배제 exclusive 원칙 - 컴포넌트를 더욱 작게 만듬  

<이미지>
<출처 - Clen Architecture e-book 캡처>

REP와 CRP에만 중점을 두면, 사소한 변경이 생겼을 때 너무 많은 컴포넌트에 영향을 미치는 상황이 발생  
CCP와 REP에만 중점을 두면, 불 필요한 릴리즈가 빈번해지는 상황

프로젝트 컴포넌트 구조는 시간과 성숙도에 따라 변하는 것
* 일반적으로 프로젝트는 삼각형의 오른쪽에서 시작 : 재사용성만 희생
* 프로젝트가 성숙하고 그 프로젝트로부터 파생된 또 다른 프로젝트가 시작되면, 프로젝트는 삼각형에서 점차 왼쪽으로 이동

### 결론
어느클래스들을 묶어서 컴포넌트로 만들지를 결정할 때, 재사용성과 개발 가능성이라는 상충하는 힘을 반드시 고려해야함  
시간이 흐름에 따라 프로젝트의 초점이 개발 가능성에서 재사용성으로 바뀌고,   
그에 따라 컴포넌트를 구성하는 방식도 조금씩 흐트러지고 또 진화함   

## 14장 컴포넌트 결합