# 4부

## 12장 컴포넌트
컴포넌트는 시스템의 구성요소로 배포할 수 있는 가장 작은 단위  (Java-`.jar`, Ruby-`.gem`, iOS - `.ipa`)  
여러 컴포넌트를 서로 링크해서 실행 가능한 단일 파일로 생성할 수 있음  
잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능함, 따라서 독립적으로 개발 가능한 능력을 갖춰야함

### 컴포넌트의 간략한 역사
메모리가 너무 작아서 소스 코드 전체를 메모리에 상주시킬 수 없었음  
컴파일 시간을 단축시키기 위해 프로그래머는 함수 라이브러리의소스 코드를 애플리 케이션 코드로부터 분리  
프로그램과 라이브러리가 사용하는 메모리가 늘어날 수록 이와 같은 단편화는 계속 될 수 밖에 없었음

### 재배치성
해결책은 재배치가 가능한 바이너리 relocatable binary  
지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정  
링킹로더 Linking Loader : 외부 정의를 로드할 위치가 정해지기만 하면 로더가 외부 참조를 외부 정의에 링크시킬 수 있음

### 링커
링킹 로더가 너무 느려지는 시기가 옴  
로드와 링커를 분리함, 컴파일-링크 시간이 병목 구간  
하드웨어의 발전으로 로드와 링크가 동시에 가능  
컴포넌트 플러그인 아키텍처 Component Plugin Architecture가 탄생

### 결론
소프트웨어 컴포넌트 : 런타임에 프러그인 형태로 결합할 수 있는 동적 링크파일  
현재는 기본으로 쉽게 컴포넌트 플러그인 아키텍처를 적용할 수 있음

## 13장 컴포넌트 응집도
어떤 클래스를 어떤 컴포넌트에 포함시켜야 하는 지는 중요한 결정사항  
컴포넌트 응집도와 관련된 세가지 원칙  
- REP, Reuse/Release Equivalence Principle : 재사용/릴리스 등가 원칙
- CCP, Common Closure Principle : 공통 폐쇄 원칙
- CRP, Common Reuse Principle : 공통 재사용 원칙

### REP : 재사용/릴리스 등가 원칙
> 재사용 단위는 릴리스 단위와 같음

소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함  
컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야함  

릴리즈 문서 작성과 릴리즈 번호를 주는 이유  
* 릴리스 번호가 없다면 재사용 컴포넌트들이 서로 호환되는지 보증할 방법이 전혀없음
* 새로운 버전이 언제 출시되고 무엇이 변했는지 소프트웨어 개발자들이 알아야함

### CCP: 공통 폐쇄 원칙

**CCP는 `SRP`를 컴포넌트 관점에서 다시 쓴 것**, 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안됨  
대부분의 애플리케이션에서 유지보수성은 재사용성 보다 훨씬 중요  
애플리케이션 코드가 반드시 변경되어야 한다면, 여러 컴포넌트에 분산되어 발생하기보다 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다  
* 변경된 컴포넌트에 의존하지 않는 다른 컴포넌트는 다시 검증하거나 배포할 필요 없음
* 소프트웨어를 릴리즈, 재검증, 배포하는 일과 관련된 작업량을 최소화 할 수 있음  
> SRP : 서로 다른 이유로 변경되는 메서드를 서로 다른 클래스로 분리  
> CCP : 서로 다른 이유로 변경되는 클래스를 서로 다른 컴포넌트로 분리  
> * 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶기,   
> 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하기

**CCP는 `OCP` 원칙과도 유사함**,  Closure의 의미가 Close와 같음  
발생할 가능성이 있거나 과거에 발생했던 대다수의 공통적인 변경에 대해 클래스가 닫혀 있도록 설계하는 OCP를 확대 적용해서,  
CCP에서는 동일한 유형의 변경에 대해 닫혀 있는 클래스들을 하나의 컴포넌트로 묶음

### CPR: 공통 재사용 원칙
> 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 않기

CRP도 클래스와 모듈을 어느 컴포넌트에 위치시킬지 결정할 때 도움되는 원칙.  
재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야함  
컴포넌트 내부에서는 클래스들 사이에 수 많은 의존성이 존재한다 예상 가능  
> Container 클래스와 해당 클래스의 Iterator 클래스가 있을 때, 서로 강하게 결합되어 있기 때문에 함께 재사용 됨    
> 따라서 두 클래스는 동일한 컴포넌트에 위치해야함  

의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야함  
CRP는 어떤 클래스를 한데 묶어도 되는지보다는, 어떤 클래스를 한데 묶어서는 안 되는지에 대해 훨씬 더 많은 이야기를 함  
강하게 결합되지 않은 클래스들은 동일한 컴포넌트에 위치시켜서는 안됨

**CRP는 `ISP`의 포괄적인 버전**, 
> ISP : 사용하지 않는 메서드가 있는 클래스에 의존하지 않기  
> CRP : 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 않기  
> " 필요하지 않는 것에 의존하지 않기 "

### 컴포넌트 응집도에 대한 균형 다이어그램
컴포넌트 응집도에 관해 세 원칙이 상충됨  
REP와 CCP는 포함 inclusive 원칙 - 컴포넌트를 더욱 크게 만듬  
CRP는 배제 exclusive 원칙 - 컴포넌트를 더욱 작게 만듬  

![IMG_59EC1549CA56-1](https://user-images.githubusercontent.com/24707229/153420006-047c9b22-d068-4d31-89b8-b1f5d74a871d.jpeg)  
<출처 - Clen Architecture e-book 캡처>

REP와 CRP에만 중점을 두면, 사소한 변경이 생겼을 때 너무 많은 컴포넌트에 영향을 미치는 상황이 발생  
CCP와 REP에만 중점을 두면, 불 필요한 릴리즈가 빈번해지는 상황

프로젝트 컴포넌트 구조는 시간과 성숙도에 따라 변하는 것
* 일반적으로 프로젝트는 삼각형의 오른쪽에서 시작 : 재사용성만 희생
* 프로젝트가 성숙하고 그 프로젝트로부터 파생된 또 다른 프로젝트가 시작되면, 프로젝트는 삼각형에서 점차 왼쪽으로 이동

### 결론
어느클래스들을 묶어서 컴포넌트로 만들지를 결정할 때, 재사용성과 개발 가능성이라는 상충하는 힘을 반드시 고려해야함  
시간이 흐름에 따라 프로젝트의 초점이 개발 가능성에서 재사용성으로 바뀌고,   
그에 따라 컴포넌트를 구성하는 방식도 조금씩 흐트러지고 또 진화함   

## 14장 컴포넌트 결합
개발 가능성과 논리적 설계 사이의 균형  
컴포넌트 구조와 관련된 아키텍처를 침범하는 힘은 기술적, 정치적, 가변적  
### ADP : 의존성 비순환 원칙
> 컴포넌트 의존성 그래프에 순환 cycle이 있어서는 안됨  

`숙취 증후근 the morning after syndrome` : 누군가 퇴근한 당신보다 더 늦게 까지 일하다 의존하고 있던 무언가를 수정해버려 동작을 안함  
숙취 증후근의 해결책  

**주 단위 빌드 (Weekly Build)** - 5일 중 4일간 개인 개발 하루동안 통합
    * 프로젝트 커지면 통합에 시간이 늘어나며 효율성 나빠짐

**순한 의존성 제거하기** - 개발 환경을 릴리즈 가능한 컴포넌트 단위로 분리
    * 어떤 팀도 다른 팀에 의해 좌우되지 않음, 특정 컴포넌트가 변경 되더라도 다른팀에 즉각 영향을 주지 않음
    * 컴포넌트 사이의 의존성 구조에 순환이 있어서는 안됨, 순환이 생기면 `숙취 증후군`을 피해 갈 수 없음
    * 비 순환 방향 그래프 Directed Acyclic Graph, DAG : 컴포넌트 다이어그램에서 컴포넌트를 조립해서 애플리케이션을 만드는 다소 전형적인 구조
        * 컴포넌트는 정점 vertex
        * 의존성 관계는 방향이 있는 간선 directed edge  
        "구성요소 간 의존성을 파악하고 있으면 시스템을 빌드하는 방법을 알 수 있음"

**순환이 컴포넌트 의존성 그래프에 미치는 영향**  
의존성 그래프에 순환이 있으면
* 여러 클래스 중 하나에 간단한 단위 테스트를 실행하는 데도, 많고 다양한 라이브러리와 다른 사람들의 많은 작업물을 포함됨
* 컴포넌트를 어떤 순서로 빌드해야 올바를지 파악하기 상당히 힘듬

**순환 끊기**  
컴포넌트 사이의 순환을 끊고 의존성을 다시 DAG로 원상복구하는 일은 언제라독 가능함
1. 의존성 역전 원칙 DIP를 적용 - 인터페이스를 상속받아서 의존성 역전
2. 순환이 발생하는 두 컴포넌트가 모두 의존하는 새로운 컴포넌트를 만들고, 모두 의존하는 클래스들을 새로운 컴포넌트로 이동

**흐트러짐(Jitters)**  
요구사항이 변경되면 컴포넌트 구조도 변경될 수 있음
의존성 구조에 순환이 발생하는지를 항상 관찰해야함

### 하향식(top-down) 설계
컴포넌트 구조는 하향식으로 설계 불가능  
시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화함  

컴포넌트 의존성 다이어그램은 애플리케이션의 빌드가능성과 유지보수성을 보여주는 지도와 같음   
-> 컴포넌트 구조는 초기에 설계할 수 없는 이유

의존성 구조와 관련된 최우선 관심사는 변동성을 격리하는 일
컴포넌트 의존성 구조는 시스템의 논리적 설계에 발 맞춰 성장하며 또 진화해야 함

### SDP : 안정된 의존성 법칙  
> 안정성의 방향으로(더 안정된 쪽에) 의존하기

변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대 안됨  
안정된 의존성 법칙 Stable Dependencies Principle, SDP을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있음

**안정성 Stability**  
소프트웨어 컴포넌트를 변경하기 어렵게 만드는 확실한 방법 하나는 수많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것  
컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 안정적,  
사소한 변경이라도 의존하는 모든 컴포넌트를 만족시키며 변경하려면 상당히 힘듬  

> X 컴포넌트는 세 컴포넌트를 `책임짐`, 어디에도 의존하지 않으므로 `독립적`  
> Y 컴포넌트는 어떤 컴포넌트도 의존하지 않으므로 `책임성이 없음`, 세 컴포넌트에 의존하므로 변경발생 가능한 외부 요인이 3개 `의존적`

**안정성 지표**
의존성의 개수를 세어보는 방법
- Fan-in : 안으로 들어오는 의존성, 컴포넌트 내부의 클래스에 의존하는 컴포넌트 외부의 클래스 개수
- Fan-out : 바깥으로 나가는 의존성, 컴포넌트 외부의 클래스에 의존하는 컴포넌트 내부의 클래스 개수를 나타냄
- I (불안정성) : *I* = Fan-out ÷ (Fan-in + Fan-out)   
    [0, 1] 범위값으로 
    * *I* = 0 이면 최고로 안정된 컴포넌트
    * *I* = 1 이면 최고로 불 안정한 컴포넌트

의존성 방향으로 갈수록 *I* 지표 값이 감소해야함

**모든 컴포넌트가 안정적이어야 하는 것은 아니다**
모든 컴포넌트가 최고로 안정적인 시스템이라면 변경이 불가능, 바람직한 상황이 아님  
다이어그램에서 불안정한 컴포넌트를 관례적으로 위쪽에 둠

**추상 컴포넌트**  
정적 타입언어를 사용할때 추상 컴포넌트를 사용, 상당히 안정적이며 덜 안정적인 컴포넌트가 의존 할 수 있는 이상적인 대상  
동적 타입언어를 사용할때 추상 컴포넌트 존재하지 않음, 의존성 역전 시 인터페이스 선언이나 상속 받을일 필요 없음

### SAP : 안정된 추상화 원칙
> 컴포넌트는 안정된 정도 만큼만 추상화되어야 함  

**고수준 정책을 어디에 위치 시켜야 하는가?** (고수준 == 추상화, 구현부 보다 정책에 가까움)  
고수준 아키텍처나 정책 결정과 관련된 소프트웨어는 자주 변경하면 안됨  
시스템에서 고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트에 위치해야함  

유연하게 만들기 -> 개방 폐쇄 원칙 OCP을 이용해서, 추상 abstract 클래스 

**안정된 추상화 원칙 Stable Abstractions Principle, SAP**  
SAP는 안정성과 추상화 정도 사이의 관계를 정의함   
안정된 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야함   
안정된 컴포넌트가 확장이 가능해지면 유연성을 얻게 되고 아키텍처를 과도하게 제약하지 않게 됨

SAP와 SDP를 결합하면 컴포넌트에 대한 DIP나 마찬가지  
SDP : 의존성이 반드시 안정성의 방향으로 향해야함  
SAP : 안정성이 결국 추상화를 의미  
-> 의존성은 추상화의 방향으로 향함

하지만 DIP는 클래스에 대한 원칙이며 클래스의 경우 중간은 존재하지 않음,  
클래스는 추상적이거나 아니거나 둘중하나  
SDP와 SAP의 조합은 컴포넌트에 대한 원칙이며, 컴포넌트는 어떤 부분은 추상적이면서 다른 부분은 안정적일 수 있음  

**추상화 정도 측정하기**  
* *Nc* : 컴포넌트의 클래스 개수
* *Na* : 컴포넌트의 추상 클래스와 인터페이스의 개수
* *A* : 추상화 정도, *A* = *Na* ÷ *Nc* [0, 1]
    A = 0, 추상 클래스가 하나도 없음  
    A = 1, 컴포넌트는 오로지 추상 클래스만 포함

*주계열*  
안정성(*I*)와 추상화정도(*A*) 사이의 관계 (*I*, *A*)

*고통의 구역*
(0, 0) 주변 구역의 컴포넌트는 매우 안정적이고 구체적임  
바람직한 상태는 아님 뻣뻣한 상태, 추상적이지 않으므로 확장할 수 없고, 안정적이므로 변경하기 상당이 어려움   
배제해야할 구역, `고통의 구역 Zone of Pain`으로 불림  

OO 애플리케이션과 데이터베이스 사이에 위치한 인터페이스는 관리하기가 굉장히 어려울 뿐만 아니라, 스키마가 변경되면 대체로 고통을 수반함  

*쓸모없는 구역*
(1, 1) 주변 구역의 컴포넌트는 최고로 추상적이고 누구도 의존하지 않음  
바람직하지 않은 상태, 쓸모가 없다, 해당 소프트웨어 엔티티는 폐기물과도 같음  

*배제구역 벗어나기*
변동성이 큰 컴포넌트 대부분은 두 배제 구역으로부터 가능한 멀리 떨어뜨려야함  
(1, 0) (0, 1)을 잇는 선분, `주계열 Main Sequence`  
주계열에 위치한 컴포넌트는 자신의 안정성에 비해 ‘너무 추상적’이지도 않고, 추상화 정도에 비해 ‘너무 불안정’ 하지도 않음  
컴포넌트가 위치할 수 있는 가장 바람직한 지점은 주계열의 두 종점  

*주계열과의 거리*
컴포넌트가 주계열 바로 위에, 또는 가까이에 있는게 바람직함  
이상적인 상태로부터 컴포넌트가 얼마나 멀리 떨어져 있는지 측정하는 지표  

*D* = ⎮*A* + *I* - 1⎮ 유효범위 [0, 1]   
*D* = 0 이면 컴포넌트가 주계열 바로 위에 위치  
*D* = 1 이면 주계열로 부터 가장 멀리 위치함  

설계를 통계적으로 분석하는 일 또한 가능  
설계에 포함된 모든 컴포넌트에 대해 D 지표와 평균과 분산을 구함  
주계열에 일치하도록 설계되었다면 평균과 분산은 0에 가까워짐

분산은 `관리 한계 control limit`를 결정하기 위한 목적으로 사용할 수 있음  
분산을 통해 다른 컴포넌트에 비해 "극히 예외적인" 컴포넌트를 식별할 수 있음

### 결론
의존성 관리 지표는 설계의 의존성과 추상화 정도가 내가 '훌륭한' 패턴이라고 생각하는 수준에 얼마나 부합하는 지를 측정  
하지만 지표는 임의로 결정된 표준을 기초로한 측정값에 지나지 않음  