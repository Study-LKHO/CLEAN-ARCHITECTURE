
# 용어정리

### 콘웨이 법칙 Conway’s law
시스템을 설계하는 조직은 필연적으로 해당 조직의 커뮤니케이션 구조를 복제한 설계물을 만들게 됨
- 소프트웨어 구조는 SW 개발팀의 구조와 같아질 것
- 일반적으로 4개의 팀이 컴파일러 작업을 하고 있다면, 4단계의 컴파일러가 만들어질 것
- 시스템을 설계할 때 우리 조직을 먼저 둘러보자는 것
- 조직 구조 / 조직의 커뮤니케이션 구조가 소프트웨어 구조를 결정함

---

### 퍼사드 패턴 Facade Pattern 
라이브러리, 프레임워크 또는 기타 복잡한 클래스 집합에 대한 단순화된 인터페이스를 제공하는 구조적 디자인 패턴 ([refactoring.guru](https://refactoring.guru/design-patterns/facade))
- 클라이언트를 복잡한 서브시스템들과 분리 시켜주는 역할
- 서브시스템들의 통합된 인터페이스를 제공하지만 **캡슐화하지는 않음** (필요하면 서브시스템 클래스의 접근 가능)

> ex) SLF4J(Simple Logging Facade for Java)  
> 다양한 로깅 프레임워크(예: java.util.logging, logback, log4j)에 대한 단순 외관 또는 추상화 역할을 하여 최종 사용자가 배포 시 원하는 로깅 프레임워크를 연결할 수 있도록 함 ([https://www.slf4j.org/](https://www.slf4j.org/))

---

### 추상 팩토리 패턴 Abstract Factory Pattern
구체적인 클래스를 지정하지 않고 관련 개체의 패밀리를 생성할 수 있는 생성 디자인 패턴 ([refactoring.guru](https://refactoring.guru/design-patterns/abstract-factory))
- 서로 관련있는 객체들을 통째로 묶어 팩토리 클래스 만들고, 이들 팩토리를 조건에 따라 생성하도록 다시 팩토리를 만들어 객체를 생성하는 패턴
- 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴

> ex) 컴퓨터 생산하는 공장 예시  
> 마우스, 키보드, 모니터의 제조사로 삼성과 엘지가 있다고 가정  
> 컴퓨터를 생산할 때 구성품은 전부 삼성 또는 엘지로 만들어야함  
> 키보드, 모니터는 삼성인데 마우스만 엘지면 안됨
 
---

## 데메테르의 원칙 Law of Demeter

---

## 최소 지식 원칙    

---

# 3부
SOLID 좋은 벽돌로 좋은 아키텍처를 정의하는 원칙,   
SOLID 원칙의 목적은 *중간 수준*의 소프트웨어 구조가  
- 변경에 유연  
- 이해하기 쉬움
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반
> *중간 수준*: 프로그래머가 SOLID 원칙을 모듈수준에서 작업할 때 적용가능. 코드의 수준보다 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는데 도움을 줌

## 7장 SRP: 단일 책임 원칙
SRP : Single Responsibility Principle 단일 책임 원칙  
각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.

SRP "단일 모듈은 변경의 이유가 하, 오직 하나뿐" ≠ "함수는 반드시 하나의, 단 하나의 일만 해야 한다"  

하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야함  
  
'응집된 cohesive' 라는 단어가 SRP를 암시.   
단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성 cohesive
> 액터 actor : 시스템이 동일한 방식으로 변경되기를 원하는 사용자나 이해관계자 집단

### 징후 1: 우발적 중복 
급여 애플리케이션의 Employee 클래스 예시 (세가지 메서드가 서로 다른 세 명의 엑터 책임짐)

서로 다른 액터가 의존하는 코드를 너무 가까이 배치했기 때문에 발생  
SRP는 서로 다른 액터가 의존하는 코드를 서로 분리해야함

### 징후 2: 병합 
서로 다른 팀의 개발자들이 하나의 Employee 클래스를 변경함 (변경사항 충돌)  

서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것

### 해결책
모두가 메서드를 각기 다른 클래스로 이동시키는 방식, 데이터와 메서드를 분리하는 방식  
1. 아무런 메서드가 없는 간단한 데이터 구조 EmployeeData 클래스를 만들어 세 클래스가 공유하도록 만들어 '우연한 중복'을 피하기  

세 클래스를 인스턴스화 하고 추적해야하는 단점 [Facade Pattern](#퍼사드-패턴-Facade-Pattern)을 이용해 해결하기  

2. EmployeeFacade 클래스가 세 클래스의 객체를 생성하고 요청된 메서드를 가지는 객체로 위임하는 일을 책임

여러 메서드가 하나의 가족을 이루고, 메서드의 가족을 포함하는 각 클래스는 하나의 유효범위가 됨.  
해당 유효범위 바깥에서는 이 가족에게 감춰진 식구(private 멤버)가 있는지를 전혀 알수 없음

### 결론  
단일 책임 원칙은 메서드와 클래스 수준의 원칙  
상위 컴포넌트 수준에서는 **공통 폐쇄 원칙(Common Closure Principle)**,  
아키텍처 수준에서는 **아키텍처 경계(Architectural Boundary)** 의 생성을 책임지는 **변경의 축(Axis of Change)** 이 됨

---

## 8장 OCP: 개방-폐쇄 원칙

### 사고실험 Thought Experiment
OCP : Open-Closed Principle 개방-폐쇄 원칙 
기존 코드를 수정하기 보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있음.

소프트웨어 개체 artifact는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 함  
소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안된다.

### 방향성 제어
### 정보 은닉
### 결론

2. OCP : 개방-폐쇄 원칙
버트란트 마이어 : 기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설게해야만 sw 시스템을 쉽게 변경할 수 있다는 것이 이 원칙의 요지.
소프트웨어 개체는 확장에 열려 있어야 하고, 변경에는 닫혀 있어야 함. 즉 소프트웨어 개체의 행위는 확장할 수 있어야 하지만 이때 개체를 변경해서는 안됨.
→ 요구사항을 살짝 확장하는 데 SW를 많이 수정해야한다면 그 아키텍트는 실패에 맞닥뜨린것.
클래스와 모듈을 설계할 때보다 아키텍처 컴포넌트 수준에서 OCP를 고려할 때 훨씬 중요한 의미 가짐.
결론
OCP는 시스템의 아키텍처를 떠받치는 원동력 중 하나.
시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 것이 목표. 달성을 위해서는 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야함.

컴포넌트 그림  
컴포넌트만 떼서 그림으로 쪼개보면 단방향으로만 이루어짐  
변경으로 부터 보호하는 쪽으로 화살표 방향이 가리킴  
View는 변경에 취약하고 Interactor는 변경에서 보호됨

---

## 9장 LSP: 리스코프 치환 원칙
### 상속을 사용하도록 가이드하기
상속을 대체하는 조합 

### 정사각형/직사각형 문제
### LSP와 아키텍처
### LSP 위배 사례
### 결론
---

## 10장 ISP: 인터페이스 분리 원칙
### ISP와 언어
### ISP와 아키텍처
### 결론
---

## 11장 DIP: 의존성 역전 원칙
### 안정된 추상화
### 팩토리
### 구체 컴포넌트
### 결론
---