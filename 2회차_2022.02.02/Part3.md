
# 용어정리

### 콘웨이 법칙 Conway’s law
시스템을 설계하는 조직은 필연적으로 해당 조직의 커뮤니케이션 구조를 복제한 설계물을 만들게 됨
- 소프트웨어 구조는 SW 개발팀의 구조와 같아질 것
- 일반적으로 4개의 팀이 컴파일러 작업을 하고 있다면, 4단계의 컴파일러가 만들어질 것
- 시스템을 설계할 때 우리 조직을 먼저 둘러보자는 것
- 조직 구조 / 조직의 커뮤니케이션 구조가 소프트웨어 구조를 결정함

---

### 퍼사드 패턴 Facade Pattern 
라이브러리, 프레임워크 또는 기타 복잡한 클래스 집합에 대한 단순화된 인터페이스를 제공하는 구조적 디자인 패턴 ([refactoring.guru](https://refactoring.guru/design-patterns/facade))
- 클라이언트를 복잡한 서브시스템들과 분리 시켜주는 역할
- 서브시스템들의 통합된 인터페이스를 제공하지만 **캡슐화하지는 않음** (필요하면 서브시스템 클래스의 접근 가능)

> ex) SLF4J(Simple Logging Facade for Java)  
> 다양한 로깅 프레임워크(예: java.util.logging, logback, log4j)에 대한 단순 외관 또는 추상화 역할을 하여 최종 사용자가 배포 시 원하는 로깅 프레임워크를 연결할 수 있도록 함 ([https://www.slf4j.org/](https://www.slf4j.org/))

---

### 추상 팩토리 패턴 Abstract Factory Pattern
구체적인 클래스를 지정하지 않고 관련 개체의 패밀리를 생성할 수 있는 생성 디자인 패턴 ([refactoring.guru](https://refactoring.guru/design-patterns/abstract-factory))
- 서로 관련있는 객체들을 통째로 묶어 팩토리 클래스 만들고, 이들 팩토리를 조건에 따라 생성하도록 다시 팩토리를 만들어 객체를 생성하는 패턴
- 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴

> ex) 컴퓨터 생산하는 공장 예시  
> 마우스, 키보드, 모니터의 제조사로 삼성과 엘지가 있다고 가정  
> 컴퓨터를 생산할 때 구성품은 전부 삼성 또는 엘지로 만들어야함  
> 키보드, 모니터는 삼성인데 마우스만 엘지면 안됨
 
---

## 데메테르의 원칙 Law of Demeter

---

## 최소 지식 원칙    

---

# 3부
SOLID 좋은 벽돌로 좋은 아키텍처를 정의하는 원칙,   
SOLID 원칙의 목적은 *중간 수준*의 소프트웨어 구조가  
- 변경에 유연  
- 이해하기 쉬움
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반
> *중간 수준*: 프로그래머가 SOLID 원칙을 모듈수준에서 작업할 때 적용가능. 코드의 수준보다 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는데 도움을 줌

## 7장 SRP: 단일 책임 원칙
SRP : Single Responsibility Principle 단일 책임 원칙  
각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.

SRP "단일 모듈은 변경의 이유가 하, 오직 하나뿐" ≠ "함수는 반드시 하나의, 단 하나의 일만 해야 한다"  

하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야함  
  
'응집된 cohesive' 라는 단어가 SRP를 암시.   
단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성 cohesive
> 액터 actor : 시스템이 동일한 방식으로 변경되기를 원하는 사용자나 이해관계자 집단

### 징후 1: 우발적 중복 
급여 애플리케이션의 Employee 클래스 예시 (세가지 메서드가 서로 다른 세 명의 엑터 책임짐)

서로 다른 액터가 의존하는 코드를 너무 가까이 배치했기 때문에 발생  
SRP는 서로 다른 액터가 의존하는 코드를 서로 분리해야함

### 징후 2: 병합 
서로 다른 팀의 개발자들이 하나의 Employee 클래스를 변경함 (변경사항 충돌)  

서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것

### 해결책
모두가 메서드를 각기 다른 클래스로 이동시키는 방식, 데이터와 메서드를 분리하는 방식  
1. 아무런 메서드가 없는 간단한 데이터 구조 EmployeeData 클래스를 만들어 세 클래스가 공유하도록 만들어 '우연한 중복'을 피하기  

세 클래스를 인스턴스화 하고 추적해야하는 단점 [Facade Pattern](#퍼사드-패턴-Facade-Pattern)을 이용해 해결하기  

2. EmployeeFacade 클래스가 세 클래스의 객체를 생성하고 요청된 메서드를 가지는 객체로 위임하는 일을 책임

여러 메서드가 하나의 가족을 이루고, 메서드의 가족을 포함하는 각 클래스는 하나의 유효범위가 됨.  
해당 유효범위 바깥에서는 이 가족에게 감춰진 식구(private 멤버)가 있는지를 전혀 알수 없음

### 결론  
단일 책임 원칙은 메서드와 클래스 수준의 원칙  
상위 컴포넌트 수준에서는 **공통 폐쇄 원칙(Common Closure Principle)**,  
아키텍처 수준에서는 **아키텍처 경계(Architectural Boundary)** 의 생성을 책임지는 **변경의 축(Axis of Change)** 이 됨

---

## 8장 OCP: 개방-폐쇄 원칙
OCP : Open-Closed Principle 개방-폐쇄 원칙 
기존 코드를 수정하기 보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있음.

소프트웨어 개체 artifact는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 함  
소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안된다.

클래스와 모듈을 설계할 때보다 아키텍처 컴포넌트 수준에서 OCP를 고려할 때 훨씬 중요한 의미를 가짐.

### 사고실험 Thought Experiment
모든 컴포넌트 관계는 단방향으로 이루어짐. **화살표는 변경으로부터 보호하려는 컴포넌트를 향하도록 그려짐.** 
> A컴포넌트에서 발생한 변경으로부터 B컴포넌트를 보호하려면 반드시 A컴포넌트가 B컴포넌트에 의존해야함

아키텍트는 기능이 어떻게 how, 왜 why, 언제 when 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화  
컴포넌트 계층구조를 이와같이 조직화하려면 저수준 컴포넌트에서 발생하느 변경으로부터 고수준 컴포넌트를 보호할 수 있음

### 방향성 제어
FinancialDataGateway 인터페이스가 두 클래스간에 위치해서 의존성 역전을 시킴  
의존성을 바로 향하지않고 두 컴포넌트 사이를 보호함  

### 정보 은닉
FinancialReportRequester 인터페이스는 방향성 제어와는 다른 목적  
Interactor 내부에 대해 너무 많이 알지 못하도록 막기 위해서 존재.   
이 인터페이스가 없었다면 Controller 컴포넌트는 FinancialEntities에 대해 **추이 종속성**을 가지게 됨  
-> 추이 종속성을 가지게 되면, '자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안 된다'는 소프트웨어 원칙을 위반 (ISP, CRP)
> 추이 종속성 transitive dependency : 클래스 A가 클래스 B에 의존하고, 다시 B가 클래스 C에 의존 -> A는 C에 의존  
> 클래스 의존성이 순환적이라면, 모든 클래스가 서로 의존하게 되는 문제가 있음.   
> 컴포넌트 수준에서의 순환성에 대해서는 의존성 비순환 원칙 (Acyclic Dependency Principle)참조

### 결론
OCP는 시스템의 아키텍처를 떠받치는 원동력 중 하나
시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 것이 목표
* 시스템을 컴포넌트 단위로 분리
* 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야함

---

## 9장 LSP: 리스코프 치환 원칙
LSP : Liscov Substitution Principle 리스코프 치환 원칙
상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 반드시 지켜야함

`S 타입`의 객체 `o1` 각각에 대응하는 `T 타입` 객체 `o2`가 있고  
`T` 타입을 이용해서 정의한 모든 `프로그램 P`에서   
`o2`의 자리에 `o1`을 치환하더라도 `P`의 행위가 변하지 않는다면,  
`S`는 `T`의 하위 타입 (SubType)

### 상속을 사용하도록 가이드하기
Billing 애플리케이션에서 행위가 License 인터페이스의 동작에 의존하지 않기 때문에,  
하위 타입은 License 타입으로 치환가능

### 정사각형/직사각형 문제
정사각형의 가로와 세로는 같고 직사각형과 달리 독립적이지 않기 때문에, Square는 Rectangle의 하위 타입으로 적합하지 않음  
타입을 서로 치환할 수 없는 대표적인 사례 (LSP 위반 사례)

### LSP와 아키텍처
상속하도록 가이드 하는 방법 더 나아가 인터페이스와 구현체에도 적용되는 설계원칙  
이상의 모든 상황은 물론 더 많은 경우에 LSP를 적용가능  
아키텍처 관점에서 LSP를 이해하는 최선의 방법은 이 원칙을 어겼을 때 시스템 아키텍처에서 무슨 일이 일어나는지 관찰하는 것

### LSP 위배 사례
다른 회사가 통합되는 사례 같이 다양한 추가가 생긴다면 분기 추가작업이 계속됨
아키텍트는 이 같은 버그로부터 시스템을 격리해야함  
아키텍트는 REST 서비스들의 인터페이스가 서로 치환 가능하지 않다는 사실을 처리하는 줒요하고 복잡한 메커니즘을 추가해야함

### 결론
LSP는 아키텍처 수준까지 확장가능  
치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염됨  
상당량의 별도 매커니즘을 추가해야 할 수도 있음

---

## 10장 ISP: 인터페이스 분리 원칙
ISP : Interface Segregation Principle 인터페이스 분리 원칙  
소프트웨어 설계자는 사용하지 않는 것에 의존하지 않아야 함  
인터페이스 분리로 각 코드는 의존하지 않고 다른 클래스의 변경과 관계없이 수정 가능

### ISP와 언어
정적 타입 언어는 사용자가 import, use 또는 include 같은 타입 선언문을 사용하도록 강제  
소스 코드에 '포함된 include' 선언문으로 인해 소스코드 의존성이 발생하고,  
이로 인해 재 컴파일 또는 재 배포가 강제되는 상황이 무조건 초래됨

### ISP와 아키텍처
필요 이상으로 많은 걸 포함하는 모듈에 의존하는 건 해로운 일  
소스 코드 의존성의 경우 불필요한 재 컴파일 또는 재 배포를 강제함  
더 고 수준인 아키텍처 수준에서도 마찬가지  

### 결론  
불 필요한 내용을 포함하는 등 무언가에 의존하면 예상치 못한 문제에 빠질 수 있음

---

## 11장 DIP: 의존성 역전 원칙
DIP : Dependency Inversion Principle 츼존성 역전 원칙
고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안됨. 세부사항이 정책에 의존해야함.

의존하지 않도록 피하고자 하는 것은 변동선이 큰 (volatile) 구체적인 요소  
이 구체적인 요소는 우리가 열심히 개발하는 중이라 자주 변경될 수 밖에 없는 모듈들

### 안정된 추상화
추상 인터페이스에 변경이 생기면 이를 구체화한 구현체들도 따라 수정해야함  
반면 구체적인 구현체는 변경이 생기더라도 구현체가 구현하는 인터페이스는 변경될 필요 없음  
따라서 인터페이스는 구현체보다 변동성이 낮음  

안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고,  
안정된 추상 인터페이스를 선호하는 아키텍처  

> 코딩 실천법  
> * 변동성이 큰 구체 클래스를 참조하지 않기
> * 변동성이 큰 구체 클래스로부터 파생하지 않기
> * 구체 함수를 오버라이드 하지 않기
> * 구체적이며 변동성이 크다면 절대 그 이름을 언급하지 않기

### 팩토리
곡선은 아키텍처의 경계로 시스템을 두가지 컴포넌트로 분리함  
`추상 컴포넌트`는 애플리케이션의 모든 고수준 업무 규칙을 포함  
`구체 컴포넌트`는 업무 규칙을 다루기 위해 필요한 모든 세부사항을 포함  
제어흐름은 소스코드 의존성과는 정반대 방향으로 곡선을 가로지른다는 점  
소스코드 의존성은 제어흐름과는 반대방향으로 역전됨 -> 의존성 역전 Dependency Inversion

### 구체 컴포넌트
DIP 위배를 모두 없앨 수는 없음,  
하지만 DIP를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있고,  
이를 통해 시스템의 나머지 부분과는 분리 가능

### 결론
아키텍처 경계의 곡선을 그려서 보면 구체적인 것들로부터 추상적인 것들을 분리함  
의존성은 이 곡선을 경계로, 더 추상적인 엔티티가 있는 쪽으로만 향함  
제어 흐름은 소스코드 의존성과 반대방향으로 곡선을 가로지름, 즉 소스코드 의존성은 제어흐름과 반대 방향으로 역전됨
의존성 규칙 Dependency Rule  

---